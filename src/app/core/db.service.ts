import { inject, Injectable } from '@angular/core';
import { doc, Firestore, getDoc, getDocs, collection, addDoc, updateDoc, deleteDoc, Query, FirestoreError, query, where, orderBy, limit, startAfter, endBefore, startAt, endAt, WhereFilterOp, OrderByDirection, limitToLast, setDoc, writeBatch, QueryDocumentSnapshot, DocumentData, DocumentSnapshot } from '@angular/fire/firestore';

@Injectable({
  providedIn: 'root'
})
export class DbService {
  private firestore = inject(Firestore);

  constructor() { }

  /**
   * @description Get a document from the database
   * @param collection - The collection name
   * @param id - The document ID
   * @returns The document
   */
  async get(collection: string, id: string) {
    if (!collection?.trim()) throw new Error('Collection name is required');
    if (!id?.trim()) throw new Error('Document ID is required');
    try {
      const docRef = doc(this.firestore, collection, id);
      const docSnap = await getDoc(docRef);
      if (docSnap.exists()) {
        return this.mapDoc(docSnap);
      } else {
        return null;
      }
    } catch (error) {
      throw this.handleDbError(error as FirestoreError);
    }
  }

  /**
   * @description Get all documents from a collection
   * @param collectionName - The collection name
   * @returns All documents
   */
  async getAll(collectionName: string) {
    if (!collectionName?.trim()) throw new Error('Collection name is required');
    try {
      const querySnapshot = await getDocs(collection(this.firestore, collectionName));
      if (querySnapshot.empty) {
        return [];
      }
      return this.mapDocs(querySnapshot.docs);
    } catch (error) {
      throw this.handleDbError(error as FirestoreError);
    }
  }

  /**
   * @description Create a document in a collection
   * @param collectionName - The collection name
   * @param data - The document data
   * @returns The document ID
   */
  async create(collectionName: string, data: any) {
    if (!collectionName?.trim()) throw new Error('Collection name is required');
    if (!data) throw new Error('Data is required');
    try {
      const docRef = await addDoc(collection(this.firestore, collectionName), data);
      return docRef.id;
    } catch (error) {
      throw this.handleDbError(error as FirestoreError);
    }
  }

  /**
   * @description Create a document in a collection with a specific ID
   * @dev This is useful to create for example a user document with a specific ID that was generated by the auth service
   * @param collectionName - The collection name
   * @param id - The document ID
   * @param data - The document data
   * @returns The document
   */
  async createWithId(collectionName: string, id: string, data: any) {
    if (!collectionName?.trim()) throw new Error('Collection name is required');
    if (!id?.trim()) throw new Error('Document ID is required');
    if (!data) throw new Error('Data is required');
    try {
      const docRef = await setDoc(doc(this.firestore, collectionName, id), data);
      return docRef;
    } catch (error) {
      throw this.handleDbError(error as FirestoreError);
    }
  }

  /**
   * @description Create multiple documents in a collection
   * @param collectionName - The collection name
   * @param data - The documents data
   */
  async bulkCreate(collectionName: string, data: any[]) {
    if (!collectionName?.trim()) throw new Error('Collection name is required');
    if (!Array.isArray(data) || !data.length) throw new Error('Data array is required and must not be empty');
    try {
      const batch = writeBatch(this.firestore);
      data.forEach(item => batch.set(doc(collection(this.firestore, collectionName)), item));
      await batch.commit();
    } catch (error) {
      throw this.handleDbError(error as FirestoreError);
    }
  }

  /**
   * @description Set a document in a collection
   * @param collectionName - The collection name
   * @param id - The document ID
   * @param data - The document data
   */
  async set(collectionName: string, id: string, data: any) {
    if (!collectionName?.trim()) throw new Error('Collection name is required');
    if (!id?.trim()) throw new Error('Document ID is required');
    if (!data) throw new Error('Data is required');
    try {
      const docRef = doc(this.firestore, collectionName, id);
      await setDoc(docRef, data);
    } catch (error) {
      throw this.handleDbError(error as FirestoreError);
    }
  }

  /**
   * @description Update a document in a collection
   * @param collectionName - The collection name
   * @param id - The document ID
   * @param data - The document data
   */
  async update(collectionName: string, id: string, data: any) {
    if (!collectionName?.trim()) throw new Error('Collection name is required');
    if (!id?.trim()) throw new Error('Document ID is required');
    if (!data || Object.keys(data).length === 0) throw new Error('Update data is required and must not be empty');
    try {
      const docRef = doc(this.firestore, collectionName, id);
      await updateDoc(docRef, data);
    } catch (error) {
      throw this.handleDbError(error as FirestoreError);
    }
  }

  /**
   * @description Update multiple documents in a collection
   * @param collectionName - The collection name
   * @param data - The documents data
   */
  async bulkUpdate(collectionName: string, data: any[]) {
    if (!collectionName?.trim()) throw new Error('Collection name is required');
    if (!Array.isArray(data) || !data.length) throw new Error('Data array is required and must not be empty');
    if (!data.every(item => item.id)) throw new Error('Each item in the update must have an id');
    try {
      const batch = writeBatch(this.firestore);
      data.forEach(item => batch.update(doc(collection(this.firestore, collectionName)), item));
      await batch.commit();
    } catch (error) {
      throw this.handleDbError(error as FirestoreError);
    }
  }

  /**
   * @description Delete a document from a collection
   * @param collectionName - The collection name
   * @param id - The document ID
   */
  async delete(collectionName: string, id: string) {
    if (!collectionName?.trim()) throw new Error('Collection name is required');
    if (!id?.trim()) throw new Error('Document ID is required');
    try {
      const docRef = doc(this.firestore, collectionName, id);
      await deleteDoc(docRef);
    } catch (error) {
      throw this.handleDbError(error as FirestoreError);
    }
  }

  /**
   * @description Delete multiple documents from a collection
   * @param collectionName - The collection name
   * @param ids - The documents IDs
   */
  async bulkDelete(collectionName: string, ids: string[]) {
    if (!collectionName?.trim()) throw new Error('Collection name is required');
    if (!Array.isArray(ids) || !ids.length) throw new Error('IDs array is required and must not be empty');
    if (!ids.every(id => id?.trim())) throw new Error('All IDs must be valid strings');
    try {
      const batch = writeBatch(this.firestore);
      ids.forEach(id => batch.delete(doc(collection(this.firestore, collectionName, id))));
      await batch.commit();
    } catch (error) {
      throw this.handleDbError(error as FirestoreError);
    }
  }

  /**
   * @description Delete an entire collection
   * @param collectionName - The collection name
   */
  async deleteCollection(collectionName: string) {
    if (!collectionName?.trim()) throw new Error('Collection name is required');
    try {
      const querySnapshot = await getDocs(collection(this.firestore, collectionName));
      const deletePromises = querySnapshot.docs.map(doc => deleteDoc(doc.ref));
      await Promise.all(deletePromises);
    } catch (error) {
      throw this.handleDbError(error as FirestoreError);
    }
  }

  /**
   * @description Query a collection
   * @param collectionName - The collection name
   * @param queryConstraints - The query constraints
   * @returns The query
   */
  query(collectionName: string, ...queryConstraints: any[]) {
    if (!collectionName?.trim()) throw new Error('Collection name is required');
    const baseQuery = collection(this.firestore, collectionName);
    return {
      where: (fieldPath: string, opStr: WhereFilterOp, value: unknown) =>
        this.query(collectionName, ...queryConstraints, where(fieldPath, opStr, value)),

      orderBy: (fieldPath: string, directionStr: OrderByDirection = 'asc') =>
        this.query(collectionName, ...queryConstraints, orderBy(fieldPath, directionStr)),

      limit: (limitCount: number) =>
        this.query(collectionName, ...queryConstraints, limit(limitCount)),

      limitToLast: (limitCount: number) =>
        this.query(collectionName, ...queryConstraints, limitToLast(limitCount)),

      startAfter: (...snapOrFieldValues: any[]) =>
        this.query(collectionName, ...queryConstraints, startAfter(...snapOrFieldValues)),

      startAt: (...snapOrFieldValues: any[]) =>
        this.query(collectionName, ...queryConstraints, startAt(...snapOrFieldValues)),

      endBefore: (...snapOrFieldValues: any[]) =>
        this.query(collectionName, ...queryConstraints, endBefore(...snapOrFieldValues)),

      endAt: (...snapOrFieldValues: any[]) =>
        this.query(collectionName, ...queryConstraints, endAt(...snapOrFieldValues)),

      execute: async () => {
        const finalQuery = query(baseQuery, ...queryConstraints);
        return this.find(finalQuery);
      }
    };
  }

  private async find(query: Query) {
    try {
      const querySnapshot = await getDocs(query);
      if (querySnapshot.empty) {
        return [];
      }
      return this.mapDocs(querySnapshot.docs);
    } catch (error) {
      throw this.handleDbError(error as FirestoreError);
    }
  }

  private mapDoc(doc: DocumentSnapshot<DocumentData>) {
    return {
      id: doc.id,
      ...doc.data()
    };
  }

  private mapDocs(docs: QueryDocumentSnapshot<DocumentData>[]) {
    return docs.map((doc) => ({
      id: doc.id,
      ...doc.data()
    }));
  }

  private handleDbError(error: FirestoreError | Error) {
    // If it's not a FirestoreError, return the custom validation error message
    if (!('code' in error)) {
      return error.message;
    }

    let message = 'An unknown error occurred';
    switch (error.code) {
      case 'cancelled':
        message = 'The operation was cancelled';
        break;
      case 'unknown':
        message = 'An unknown error occurred';
        break;
      case 'invalid-argument':
        message = 'Invalid data provided';
        break;
      case 'deadline-exceeded':
        message = 'Operation timed out';
        break;
      case 'not-found':
        message = 'The requested document was not found';
        break;
      case 'already-exists':
        message = 'Document already exists';
        break;
      case 'permission-denied':
        message = 'You are not authorized to perform this action';
        break;
      case 'resource-exhausted':
        message = 'Too many requests, please try again later';
        break;
      case 'failed-precondition':
        message = 'Operation cannot be executed in current system state';
        break;
      case 'aborted':
        message = 'The operation was aborted';
        break;
      case 'out-of-range':
        message = 'Operation was attempted past the valid range';
        break;
      case 'unimplemented':
        message = 'Operation is not implemented or supported';
        break;
      case 'internal':
        message = 'Internal error occurred, please try again';
        break;
      case 'unavailable':
        message = 'Service is currently unavailable, please try again later';
        break;
      case 'data-loss':
        message = 'Unrecoverable data loss or corruption';
        break;
      case 'unauthenticated':
        message = 'User is not authenticated';
        break;
      default:
        // Return the original error message if it doesn't match any FirestoreError code
        message = error.message;
        break;
    }
    return message;
  }


}
